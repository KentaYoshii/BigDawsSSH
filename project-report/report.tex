\documentclass[10pt,sigconf]{acmart}

\settopmatter{printacmref=false, printccs=false, printfolios=false}
\renewcommand\footnotetextcopyrightpermission[1]{}

% \usepackage{booktabs} % For formal tables

\graphicspath{{figure/}{figures/}}

% Copyright
% \setcopyright{acmcopyright}
% \setcopyright{acmlicensed}
% \setcopyright{rightsretained}
% \setcopyright{usgov}
% \setcopyright{usgovmixed}
% \setcopyright{cagov}
% \setcopyright{cagovmixed}


% % DOI
% \acmDOI{10.475/123_4}

% % ISBN
% \acmISBN{123-4567-24-567/08/06}

% %Conference
% \acmConference[SHORTNAME'23]{ACM Long Conference Name conference}{July 1997}{City, State, Country} 
% \acmYear{2023}
% \copyrightyear{2023}

% \acmPrice{15.00}


\begin{document}
\title{BigDawsSSH}
% \titlenote{Produces the permission block, and copyright information}
% \subtitle{Paper \#, XXX pages}

\author{Kenta Yoshii}

\email{kenta_yoshii@brown.edu}

% \author{Firstname Lastname}
% \orcid{1234-5678-9012}
% \affiliation{%
%   \institution{Affiliation}
%   \streetaddress{Address}
%   \city{City} 
%   \state{State} 
%   \postcode{Zipcode}
% }
% \email{email@domain.com}

% \author{Firstname Lastname}
% \orcid{1234-5678-9012}
% \affiliation{%
%   \institution{Affiliation}
% }
% \email{email@domain.com}

% \author{Firstname Lastname}
% \orcid{1234-5678-9012}
% \affiliation{%
%   \institution{Affiliation}
% }
% \email{email@domain.com}

% \author{Firstname Lastname}
% \orcid{1234-5678-9012}
% \affiliation{%
%   \institution{Affiliation}
% }
% \email{email@domain.com}


% The default list of authors is too long for headers}


% \begin{abstract}
% This paper provides a sample of a \LaTeX\ document which conforms,
% somewhat loosely, to the formatting guidelines for
% ACM SIG Proceedings.\footnote{This is an abstract footnote}
% \end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below. 
%

% We no longer use \terms command
%\terms{Theory}

% \keywords{ACM proceedings}

\begin{abstract}
  In BigDawsSSH, I have implemented two central protocols in the Secure Shell Protocol. Namely, the \textbf{Transport protocol} that focuses on establishing a secure and confidential connection between a server and a client and the \textbf{Authentication protocol} which then focuses on authenticating the user. \textbf{Connection Protocol}, which builds on top of these two protocols, is not implemented, as I deemed irrelevant to the class material. 
\end{abstract}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle
\pagestyle{plain}

\section{Introduction}
Secure Shell(SSH) is a network protocol that allows users to access and manage remote computers and servers over an unsecured network. Most notably, SSH provides a secure channel for data communication between two computers, encrypting any data that pass between them. In this project, I deep dived into the actual protocol to understand how this secure channel is established and how the server and the client are authenticated. In section 2, I will briefly go over some basic concepts in cryptography necessary to understand the workings of these protocols and explain how they are used. In section 3 of the report, I will explain in depth the two protocols needed for the secure channel to be established. In section 4, I will explain BigDawsSSH more in detail. In the final section, I will discuss some difficulties I encountered along the way.

\section{Prerequisite Knowledge}
\paragraph{\textbf{Diffie-Hellman Key Exchange}} Diffie-Hellman key exchange is an algorithm used to derive a shared secret between two parties over a public channel. Since this alogrithm was discussed in-depth in class already, I will not explain the way this shared secret is derived. In the context of SSH, DH key exchange is used to derive a shared secret $\mathbf{k}$. This $k$ then is also used to derive a unique hash $\mathbf{H}$ which uniquely identifies the SSH session. In Diffie-Hellman, the group used determines the strength of the keys used in the exchange. In SSH and BigDawsSSH, the following two groups are supported \[
  diffie-hellman-group1-sha1  
\]
\[
  diffie-hellman-group14-sha1  
\]
Which of these two is used is determined in the algorithm negotation stage which takes place in the Transport protocol. In SSH, Key Re-exchange is also supported. If that happens, a new instance of DH key exchange is run, $k'$ is computed, and keys for encryption and integrity are renewed. However, the unique hash $H$ remains unchanged.
\paragraph{\textbf{Symmetric Key Encryption}} Symmetrical encryption is a type of encryption where one key can be used to encrypt messages to the opposite party, and also to decrypt the messages received from the other participant. Symmetric keys are used by SSH in order to encrypt the entire connection. These keys are session-based and can be renewed if either party wishes so. The actual derivation of this symmetric key and starting of data encryption take place at the end of key exchange and will be discussed in more detail in section 3 Transport protocol. SSH offers many different kinds of ciphers, but in BigDawsSSH the mainly used three are selected. \[3des-cbc\]\[aes128-cbc\]\[aes256-cbc\]
Until the key exchange is done, no data encryption is done. 
\paragraph{\textbf{Asymmetric Key Encryption}}
Asymmetrical encryption is different from symmetrical encryption as two associated keys are needed. The first key, public key, is used to encrypt messages and nothing else can be achieved using it (it only goes in one-way). The second key, private key, is the only component capable of decrypting messages that were encrypted using the associated public key. By virtue of this fact, any entity capable of decrypting these messages has demonstrated that they are in control of the private key. SSH takes advantage of this fact and use asymmetric encryption to perform authentication. In BigDawsSSH, there are two such places. 
\begin{enumerate}
  \item Server Host Authentication\\
  The client starts up knowing the SSH server's public key. They then encrypt all the messages they send using the server's public key until shared secret is established. This way, the client can be sure that they are indeed talking to the server. For this part in BigDawsSSH, \[ssh-dss\] is used.
  \item Client Authentication\\
  This takes place in the second protocol, Authentication protocol. The actual process is discussed in section 3. For this part in BigDawsSSH, \[ssh-rsa\] is used.
\end{enumerate}
\paragraph{\textbf{Hashing}} Cryptographic hash functions are methods of creating a succinct “signature” or summary of a set of information. They are very difficult to be reversed (e.g., guessing $x$ from $h(x)$ is difficult) and practically unique. Using the same hashing function and message should produce the same hash; modifying any portion of the data should produce an entirely different hash. Hence, a client/server should not be able to produce the original message from a given hash, but they should be able to tell if a given message produced a given hash. Given these properties, the main use of hashing in SSH is with HMAC, or hash-based message authentication codes. These are used to ensure the message text that's received is intact and unmodified. The specific hashing schemes supported in BigDawsSSH are \[hmac-sha1\]\[hmac-sha96\]
Similarly to encryption scheme, hmac scheme is also negotiated with the client in the Transport protocol. After the key derivation, HMAC are computed on unencrypted packet and attached to the encrypted packet for the receiver to verify. More on this later.
\section{SSH protocols}
\subsection{Transport Protocol}
When a client first connects to the server, the client and the server will perform a protocol called \textbf{Transport protocol}. This protocol is used for the two parties to reach an agreement on the following important things.
\begin{enumerate}
  \item \textbf{SSH Version} 
  
  This describes the SSH version, software version and other various features for that session. Each party will exchange a protocol version upon connection.
  \item \textbf{Algorithms}
  
  These include encryption algorithm, MAC scheme, compression algorithm, and key exchange algorithm among other things.
  \item \textbf{Shared Secret}
  
  This shared secret is derived from the key exchange algorithm agreed above. It is used to derive symmetric keys for the other algorithms for later use
  \item \textbf{Exchange Hash (Session Identifier)}
  
  This hash is also used in tandem with shared secret to derive cryptographic keys. It also serves as an unique session identifier, which will be used in the authentication protocol.
  \item \textbf{Cryptographic Keys}
  
  These keys are the final output from this protocol. They are used to encrypt/decrypt and sign/verify any future data that will travel between the two to maintain confidentiality and integrity.
\end{enumerate}
\paragraph{\textbf{Server Authentication}}
In the proposal, we briefly discussed about the potential Man in the Middle attack that could happen. The RFC does not strictly enforce a server authentication but in BigDawsSSH, this is enforced. Each SSH client will have a local store of public keys of different SSH servers it may talk to. After the protocol version exchange and up until encryption of packets begin, the SSH server will sign the packets it send out using its corresponding secret key. The clients will perform a verification on each of these packet to make sure that they are indeed coming from the server. In BigDawsSSH, ssh-dss is used for this purpose.
\paragraph{\textbf{Algorithm Negotiation}}
Upon completing the version exchange, algorithm negotation immediately begins. Each side will send the other party name-lists of algorithms (in the order of preference). A certain set of rules (e.g., the server also needs to support the algorithm the client prefers the most) are used to determine the algorithms that will be used in the later protocol. In this stage of the transport protocol, the following things are agreed upon
\begin{enumerate}
  \item \textbf{Key Exchange Algorithm} that takes place in the next stage to get a shared secret
  \item \textbf{Server Host Key Algorithm}
  \item \textbf{Encryption Scheme} that will be used for the duration of this session
  \item \textbf{MAC Algorithm} to preserve message integrity
  \item \textbf{Compression Algorithm} if any
  \item \textbf{Language} to be used in the particular session
\end{enumerate} 
\paragraph{\textbf{Key Exchange}}
Among many other things, both sides will agree on a key exchange algorithm. In BigDawsSSH, both diffie-hellman-group1-sha1 and diffie-hellman-group14-sha1 are supported. The steps are follows:
\begin{enumerate}
  \item Client randomly samples $a$ and computes $g^{a}$. Client then sends its public value $e = g^{a}$ to the server
  \item Server randomly samples $b$ and computes $f = g^{b}$. It also computes $k = e^{b}$. It then computes the hash as \[
  H = hash(V_C || V_S || I_C || I_S || K_S || e || f || k)
  \] where $V$ is the raw protocol version message bits (so $V_C$ represents client's protocol version message bits), $I$ is the raw negotiation message bits, and $K_S$ is the server's host public key. The server then signs this hash using its host private key and send to client \[(K_S, f, signature)\]
  \item Client computes $k$ and $H$. It then verifies the signature on the hash.
  \item After the key exchange is complete, each side will have an exchange hash, $H$, and shared secret $k$.
\end{enumerate}
\paragraph{\textbf{Key Generation}} After the key exchange, each side will generate 6 different values, which are 
\begin{enumerate}
  \item Client to Server Encryption Key
  \item Server to Client Encryption Key
  \item Client to Server Integrity Key
  \item Server to Client Integrity Key
  \item Client to Server Initial IV  
  \item Server to Client Initial IV
\end{enumerate}
In order for both sides to have the exact same keys, these keys are generated in a deterministic way. For example, Client to Server Initial IV is computed by \[
  hash(k || H || "A" || session\_id)
\] Other keys are computed likewise. Server to Client Initial IV is computed by substituting "A" with "B". \\\\
Here it is important that the keys and IVs are sufficient in size and in accordance with the agreed upon algorithms. For example, if the agreed upon encryption algorithm is $aes256-cbc$, the key needs to be 256 bits in length and IVs 16 bits (or the block size of cbc) in length.\\\\
The reason why we generate a new key for each direction(e.g., client $\rightarrow$ server) is to prevent mirror attack  (e.g., relaying packets sent out by server back to the server) from happening. 
\paragraph{\textbf{Binary Packet Protocol}}
Binary Paclet Protocol or BPP is the underlying protocol used to transfer data between the client and the server. In order to prevent from malicious party conducting a detail analysis on each packet, a random padding is added to the actual payload. Then $packet\_length$, $padding\_length$, $payload$, and $random\_padding$ are all encrypted with the agreed algorithm using the derived key. HMAC is also computed on the raw unencrypted Binary Packet to provide message integrity (Encrypt-and-MAC). Via these two measures, SSH makes sure the connection is both secure and confidential.
% Refer to \verb|acmart.pdf| \cite{veytsmanlatex} (\url{https://www.ctan.org/pkg/acmart}, \url{http://www.acm.org/publications/proceedings-template}) for additional examples and instructions.

\subsection{Authentication Protocol}

After a secure and confidential channel is established between the two parties, Authentication protocol is run to authenticate the SSH client. This protocol is initiated by the client issuing a service request at the end of the transport protocol (ssh-auth). In BigDawsSSH, two types of authentication schemes, further discussed below, are supported. In the beginning, the server sends the list of available authetication methods to the client. Client can choose any method in any order.
\subsubsection{Publickey}
In this scheme, a user authenticates itself by proving that they possess a secret signing key. An user will generate a key-pair in advance and send register the public key on the server. Then when the actual authentication protocol is run, the user can simply provide its username, public key, and signature computed over some other metadata and signed by the corresponding secret key. If the server successfully verifies the signature using the registered public key, then the client is considered authenticated. \\\\
In BigDawsSSH, ssh-rsa is used to perform a publickey based user authentication.
\subsubsection{Password}
In this scheme, a user is prompted a password. If the provided password exists in the SSH server's database, then that client is considered authenticated. We note that since every Binary Packet is encrypted and HMACed, password is just sent as a plaintext (no salt and/or pepper needed). \\\\
After a user is successfully authenticated, then they can start using the services (e.g., ssh-connection) that are offered by the server host.
\section{BigDawsSSH}
In this section, I will discuss a little more in detail how BigDawsSSH is implemented.
\subsection{Setup}
When the server binary starts, the following things are loaded \begin{enumerate}
  \item Server's name-lists for algorithm negotiation
  \item Server's DSA keys for server host authentication
  \item Registered users' passwords for clients' password authenticating (if they choose so)
\end{enumerate}
When the client binary starts, the following things are loaded \begin{enumerate}
  \item Client's name-lists for algorithm negotiation
  \item Server's DSA public key for authenticating the server
\end{enumerate}
\subsection{Pre-Key Exchange}
In this part, no encryption or HMAC is performed. Hence in the Binary Packet, MAC field is left as empty. \\\\
Protocol Version Exchange is performed following the rules described in RFC 4253. \\\\
Algorithm Negotiation is also performed exactly following the steps described in the RFC. To focus on cryptographic parts of this protocol, I decided to simply ignore Compression and Language, although shared values for both of them are reached.
\subsection{Key Exchange/Keys Generations}
BigDawsSSH follows the Key Exchange/Keys Generation steps exactly. It however does not support Key Re-exchange yet. 
\subsection{Client Authentication}
When the Transport protocol is done, the user is prompted for the following inputs \begin{enumerate}
  \item Username 
  \item (Authentication) Method
  \item Password (if $password$ scheme is used)
\end{enumerate}
Depending on the input for method, a different protocol is run with the server. Eventually, the user succeeds in authenticating itself and the protocol will be over.
\section{Discussion}
Here I list some difficulties I encountered along the way and how I solved them \begin{enumerate}
  \item Understanding the Protocol itself
  \\Arguably the most difficult part was understanding the protocol itself. For this I simply read the relevant RFCs over and over until I was able to understand all the different aspects of the protocol. 
  \item Handling packets 
  \\Another difficult part for me was dealing with various different kinds of messages, from negotiatio message to key exchange message, and fitting all of them into the format Binary Packet Protocol was expecting. To solve this, I used variosu struct definitions for each and every kind of messages and defning their own marshall/unmarshall functions.
  \item Support for more than one schemes
  \\Since SSH should be able to support more than one encryption/HMAC/Authentication schemes, I also struggled making BigDawsSSH do the same. Initial design was not conductive into doing this because everything was kind of hardcoded. To add support for more than one schemes, I first made everything very generic. For example, I added a handler function that invokes a specific function associated with that particular scheme.
\end{enumerate}
\section{Reference}
\begin{enumerate}
  \item RFC4250 (Message Code, etc.)
  \item RFC4251 (Protocol architecture)
  \item RFC4252 (Authentication protocol)
  \item RFC4253 (Transport protocol)
\end{enumerate}

% \bibliographystyle{acm}
% \bibliography{sigproc} 

\end{document}